<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Autonomous Collector Lander</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 2px solid #fff;
            background-color: #05051a;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-family: sans-serif;
            font-size: 14px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            min-width: 150px;
        }
        .safe { color: lime; }
        .danger { color: red; }
        .score-display { font-weight: bold; color: yellow; }

        /* Trace Log Area */
        #log-area {
            width: 800px;
            height: 100px;
            margin-top: 10px;
            background-color: #111;
            color: #eee;
            font-family: monospace;
            padding: 5px;
            border: 1px solid #444;
            overflow-y: scroll;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="log-area">Trace Log:</div>
    </div>
    
    <div id="info">
        AI Mode: <span id="ai-mode">Collect</span><br>
        AI Status: <span id="ai-status">Initializing...</span><br>
        Vertical Speed: <span id="vy-display">0.00</span><br>
        Score: <span id="score-display" class="score-display">0</span>
    </div>

    <script>
        // --- IMMEDIATE GLOBAL SETUP ---
        const logArea = document.getElementById('log-area');

        // Global DOM References 
        let canvas, ctx, aiStatusSpan, aiModeSpan, vyDisplaySpan, scoreDisplaySpan;

        let animationFrameId = null; 
        let explosionTimer = 0; 
        let notificationPermission = 'default';

        // --- Logging and Type Checking Utility ---
        
        // FIX: New function to check for NaN and halt execution
        function checkFloatAndStop(value, variableName, context = 'Global') {
            if (typeof value === 'number' && isNaN(value)) {
                const errorMessage = `CRITICAL NAN ERROR: ${variableName} in ${context} is NaN. Stopping execution.`;
                trace(errorMessage, true);
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                throw new Error(errorMessage);
            }
            return value;
        }
        
        function trace(message, isError = false) {
            if (typeof message !== 'string') message = String(message);
            if (typeof isError !== 'boolean') isError = false; 

            const time = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.textContent = `${time} [${isError ? 'ERROR' : 'INFO'}] ${message}`;
            logEntry.style.color = isError ? 'red' : 'inherit';
            
            const targetLogArea = document.getElementById('log-area') || logArea;

            if (targetLogArea) {
                targetLogArea.prepend(logEntry);
                while (targetLogArea.children.length > 50) {
                    targetLogArea.removeChild(targetLogArea.lastChild);
                }
            } else {
                 if (isError) console.error(`[${time} ERROR] ${message}`);
                 else console.log(`[${time} INFO] ${message}`);
            }

            if (isError) {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                    trace("Game loop stopped due to critical error.", true);
                }
            }
        }
        
        function checkType(variable, expectedType, variableName, context = 'game') {
            if (variable === null || variable === undefined || typeof variable !== expectedType) {
                const value = variable === null ? 'null' : variable === undefined ? 'undefined' : variable;
                const type = typeof variable;
                const errorMessage = `[${context}] CRITICAL TYPE ERROR: ${variableName} expected ${expectedType} but got ${type} (Value: ${value})`;
                trace(errorMessage, true);
                throw new Error(`Type error in ${variableName}`);
            }
        }
        
        // --- Notification Functions ---

        function requestNotificationPermission() {
            try {
                if (!("Notification" in window)) {
                    trace("Browser does not support desktop notifications.", false);
                    return;
                }
                if (Notification.permission === 'granted') {
                    notificationPermission = 'granted';
                    return;
                }

                Notification.requestPermission().then(permission => {
                    notificationPermission = permission;
                    trace(`Notification permission status: ${permission}`, false);
                }).catch(e => {
                    trace(`Failed to request notification permission: ${e.message}`, true);
                });
            } catch (e) {
                trace(`Exception in requestNotificationPermission: ${e.message}`, true);
            }
        }

        function sendNotification(title, body) {
            try {
                if (notificationPermission === 'granted') {
                    new Notification(title, {
                        body: body,
                        icon: 'https://www.google.com/s2/favicons?domain=' + window.location.hostname 
                    });
                }
            } catch (e) {
                trace(`Error sending notification: ${e.message}`, true);
            }
        }


        // --- Game Constants and State Containers ---
        const CONSTANTS = {};
        const AI_MODE = { COLLECT: 'COLLECT', LANDING: 'LANDING', NN_CONTROL: 'NN_CONTROL' };
        
        const NN_CONSTANTS = {
            INPUT_SIZE: 10,
            HIDDEN_SIZE: 16,
            OUTPUT_SIZE: 3,
            LEARNING_RATE: 0.01, 
            MAX_PLAYTHROUGHS: 50
        };

        let gameState = {
            score: 0,
            playthroughs: 0,
            currentAIMode: AI_MODE.COLLECT,
            ship: {},
            obstacles: [],
            diamonds: [],
            particles: []
        };
        
        let neuralNet;
        let dataCollector;

        // --- Neural Network Implementation ---

        class NeuralNetwork {
            constructor(inputSize, hiddenSize, outputSize, learningRate) {
                this.lr = checkFloatAndStop(learningRate, 'NN.lr', 'NN.constructor');
                this.weights_ih = this.randomMatrix(hiddenSize, inputSize); 
                this.weights_ho = this.randomMatrix(outputSize, hiddenSize);
                this.bias_h = this.randomVector(hiddenSize);
                this.bias_o = this.randomVector(outputSize);
            }
            randomMatrix(rows, cols) {
                return Array(rows).fill(0).map(() => 
                    Array(cols).fill(0).map(() => checkFloatAndStop((Math.random() * 2 - 1) * 0.01, 'NN Weight', 'NN.randomMatrix'))
                );
            }
            randomVector(size) {
                return Array(size).fill(0).map(() => checkFloatAndStop((Math.random() * 2 - 1) * 0.01, 'NN Bias', 'NN.randomVector'));
            }
            sigmoid(x) { 
                checkFloatAndStop(x, 'Sigmoid Input', 'NN.sigmoid');
                const result = 1 / (1 + Math.exp(-x)); 
                return checkFloatAndStop(result, 'Sigmoid Output', 'NN.sigmoid');
            }
            sigmoidDerivative(y) { 
                checkFloatAndStop(y, 'SigmoidDeriv Input', 'NN.sigmoidDerivative');
                const result = y * (1 - y);
                return checkFloatAndStop(result, 'SigmoidDeriv Output', 'NN.sigmoidDerivative');
            }
            dot(matrixA, matrixB) {
                if (matrixA.length === 0 || matrixB.length === 0) return [[]];
                if (matrixA[0].length !== matrixB.length) {
                    trace(`Dot product dimension mismatch: ${matrixA.length}x${matrixA[0].length} DOT ${matrixB.length}x${matrixB[0].length}`, true);
                    throw new Error("Dot product dimensions mismatch");
                }
                const resultRows = matrixA.length;
                const resultCols = matrixB[0].length;
                const result = Array(resultRows).fill(0).map(() => Array(resultCols).fill(0));
                for (let i = 0; i < resultRows; i++) {
                    for (let j = 0; j < resultCols; j++) {
                        let sum = 0;
                        for (let k = 0; k < matrixA[0].length; k++) {
                            sum += checkFloatAndStop(matrixA[i][k], 'Dot A[i][k]', 'NN.dot') * checkFloatAndStop(matrixB[k][j], 'Dot B[k][j]', 'NN.dot');
                        }
                        result[i][j] = checkFloatAndStop(sum, `Dot Result[${i}][${j}]`, 'NN.dot');
                    }
                }
                return result;
            }
            vectorToColMatrix(vector) { return vector.map(v => [v]); }
            transpose(matrix) {
                const rows = matrix.length;
                const cols = matrix[0].length;
                const result = Array(cols).fill(0).map(() => Array(rows).fill(0));
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        result[j][i] = matrix[i][j];
                    }
                }
                return result;
            }
            add(matrixA, matrixB) {
                const rows = matrixA.length;
                const cols = matrixA[0].length;
                const result = Array(rows).fill(0).map(() => Array(cols).fill(0));
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        result[i][j] = checkFloatAndStop(matrixA[i][j], 'Add A element', 'NN.add') + 
                                       checkFloatAndStop(matrixB[i][j], 'Add B element', 'NN.add');
                    }
                }
                return result;
            }
            subtract(matrixA, matrixB) {
                 const rows = matrixA.length;
                 const cols = matrixA[0].length;
                 const result = Array(rows).fill(0).map(() => Array(cols).fill(0));
                 for (let i = 0; i < rows; i++) {
                     for (let j = 0; j < cols; j++) {
                         result[i][j] = checkFloatAndStop(matrixA[i][j], 'Subtract A element', 'NN.subtract') - 
                                        checkFloatAndStop(matrixB[i][j], 'Subtract B element', 'NN.subtract');
                     }
                 }
                 return result;
            }
            multiply(matrixA, matrixB) {
                const rows = matrixA.length;
                const cols = matrixA[0].length;
                const result = Array(rows).fill(0).map(() => Array(cols).fill(0));
                if (typeof matrixB === 'number') {
                    for (let i = 0; i < rows; i++) {
                        for (let j = 0; j < cols; j++) {
                            result[i][j] = checkFloatAndStop(matrixA[i][j], 'Multiply A element', 'NN.multiply') * checkFloatAndStop(matrixB, 'Multiply scalar', 'NN.multiply');
                        }
                    }
                    return result;
                } else {
                    for (let i = 0; i < rows; i++) {
                        for (let j = 0; j < cols; j++) {
                            result[i][j] = checkFloatAndStop(matrixA[i][j], 'Multiply A element', 'NN.multiply') * checkFloatAndStop(matrixB[i][j], 'Multiply B element', 'NN.multiply');
                        }
                    }
                    return result;
                }
            }
            map(matrix, func) {
                return matrix.map(row => row.map(val => func(checkFloatAndStop(val, 'Map Input Value', 'NN.map'))));
            }
            feedforward(input_array) {
                const inputs = this.vectorToColMatrix(input_array);
                let hidden = this.dot(this.weights_ih, inputs);
                hidden = hidden.map((row, i) => [checkFloatAndStop(row[0], 'Hidden Row Val', 'NN.feedforward') + checkFloatAndStop(this.bias_h[i], 'Hidden Bias', 'NN.feedforward')]);
                const hidden_output = this.map(hidden, this.sigmoid);
                let output = this.dot(this.weights_ho, hidden_output);
                output = output.map((row, i) => [checkFloatAndStop(row[0], 'Output Row Val', 'NN.feedforward') + checkFloatAndStop(this.bias_o[i], 'Output Bias', 'NN.feedforward')]);
                const final_output = this.map(output, this.sigmoid);
                return final_output.map(row => checkFloatAndStop(row[0], 'Final Output Val', 'NN.feedforward'));
            }
            train(input_array, target_array) {
                const inputs = this.vectorToColMatrix(input_array);
                let hidden = this.dot(this.weights_ih, inputs);
                hidden = hidden.map((row, i) => [checkFloatAndStop(row[0], 'Hidden Row Val', 'NN.train') + checkFloatAndStop(this.bias_h[i], 'Hidden Bias', 'NN.train')]);
                const hidden_output = this.map(hidden, this.sigmoid);
                let output = this.dot(this.weights_ho, hidden_output);
                output = output.map((row, i) => [checkFloatAndStop(row[0], 'Output Row Val', 'NN.train') + checkFloatAndStop(this.bias_o[i], 'Output Bias', 'NN.train')]);
                const final_output = this.map(output, this.sigmoid);
                const targets = this.vectorToColMatrix(target_array);
                let output_errors = this.subtract(targets, final_output);
                let gradients = this.map(final_output, this.sigmoidDerivative);
                gradients = this.multiply(gradients, output_errors);
                gradients = this.multiply(gradients, this.lr);
                const hidden_output_T = this.transpose(hidden_output);
                let delta_weights_ho = this.dot(gradients, hidden_output_T);
                this.weights_ho = this.add(this.weights_ho, delta_weights_ho);
                
                // Correctly update output biases
                for (let i = 0; i < this.bias_o.length; i++) {
                    this.bias_o[i] += checkFloatAndStop(gradients[i][0], 'Output Gradient Val', 'NN.train');
                }
                
                const weights_ho_T = this.transpose(this.weights_ho);
                let hidden_errors = this.dot(weights_ho_T, output_errors);
                let hidden_gradients = this.map(hidden_output, this.sigmoidDerivative);
                hidden_gradients = this.multiply(hidden_gradients, hidden_errors);
                hidden_gradients = this.multiply(hidden_gradients, this.lr);
                const inputs_T = this.transpose(inputs);
                let delta_weights_ih = this.dot(hidden_gradients, inputs_T);
                this.weights_ih = this.add(this.weights_ih, delta_weights_ih);
                
                // Correctly update hidden biases
                for (let i = 0; i < this.bias_h.length; i++) {
                    this.bias_h[i] += checkFloatAndStop(hidden_gradients[i][0], 'Hidden Gradient Val', 'NN.train');
                }
                
                let errorSum = output_errors.reduce((sum, row) => {
                    const error = checkFloatAndStop(row[0], 'Output Error Val', 'NN.train.reduce');
                    return sum + error * error;
                }, 0);
                return checkFloatAndStop(errorSum, 'Final Error Sum', 'NN.train');
            }
        }
        
        class DataCollector {
            constructor() { this.data = []; }
            record(input, target_output) {
                if (input.length !== NN_CONSTANTS.INPUT_SIZE || target_output.length !== NN_CONSTANTS.OUTPUT_SIZE) {
                     trace("Data record size mismatch! Skipping entry.", true);
                     return;
                }
                this.data.push({ input, target_output });
            }
            clear() { this.data = []; }
        }

        // --- INITIALIZATION ---

        function initDOMReferences() {
            trace("Attempting to acquire DOM elements and Canvas Context...", false);
            try {
                canvas = document.getElementById('gameCanvas');
                aiStatusSpan = document.getElementById('ai-status');
                aiModeSpan = document.getElementById('ai-mode');
                vyDisplaySpan = document.getElementById('vy-display');
                scoreDisplaySpan = document.getElementById('score-display');
                
                if (!canvas || !aiStatusSpan || !aiModeSpan || !vyDisplaySpan || !scoreDisplaySpan) {
                    let missing = [];
                    if (!canvas) missing.push('canvas');
                    if (!aiStatusSpan) missing.push('ai-status');
                    if (!aiModeSpan) missing.push('ai-mode');
                    if (!vyDisplaySpan) missing.push('vy-display');
                    if (!scoreDisplaySpan) missing.push('score-display');
                    throw new Error(`Missing critical DOM elements: ${missing.join(', ')}`);
                }
                
                ctx = canvas.getContext('2d');
                if (!ctx) {
                     throw new Error("Failed to acquire 2D canvas context.");
                }
                
                if (typeof canvas.width !== 'number' || canvas.width <= 0 || typeof canvas.height !== 'number' || canvas.height <= 0) {
                     throw new Error(`Canvas dimensions are invalid (Width: ${canvas.width}, Height: ${canvas.height}).`);
                }

                trace(`SUCCESS: All DOM references and context initialized (Canvas ${canvas.width}x${canvas.height}).`, false);
            } catch (e) {
                trace(`WARNING: DOM initialization failed (${e.message}). Retrying soon.`, false);
                throw e; // Re-throw to signal failure to the startup function
            }
        }

        function initConstants() {
            trace("Setting up game constants...", false);
            CONSTANTS.GRAVITY = 0.05;
            CONSTANTS.THRUST_POWER = 0.15;
            CONSTANTS.ROTATION_SPEED = 0.05;
            CONSTANTS.GROUND_HEIGHT = 50;
            CONSTANTS.MAX_SAFE_VELOCITY = 1.0;
            CONSTANTS.CRITICAL_VELOCITY = 3.0;
            CONSTANTS.SCORE_LANDING = 100;
            CONSTANTS.SCORE_DIAMOND = 5;
            trace("Constants initialized.", false);
        }

        function initGameState(startFresh = true) {
             trace(`Initializing/Resetting game state (Start Fresh: ${startFresh}).`, false);
             if (startFresh) gameState.playthroughs = 0;
             
             gameState.ship = {
                x: canvas.width / 2,
                y: 50,
                velocity: { x: 0, y: 0 },
                angle: Math.PI / 2,
                size: 15,
                isThrusting: false,
                isAlive: true,
                hasLanded: false,
                notified: false,
                memory: { lastAction: 'Init', aiStatus: 'Cruising...' }
            };

            gameState.obstacles = [
                { x: 100, y: 300, w: 150, h: 20 }, { x: 550, y: 200, w: 100, h: 20 },
                { x: 300, y: 450, w: 200, h: 20 }, { x: 50, y: 150, w: 50, h: 50 },
                { x: 650, y: 400, w: 150, h: 20 }
            ];

            gameState.diamonds = [];
            for (let i = 0; i < 10; i++) {
                gameState.diamonds.push({
                    x: Math.random() * (canvas.width - 40) + 20,
                    y: Math.random() * (canvas.height - CONSTANTS.GROUND_HEIGHT - 50) + 20,
                    size: 5,
                    collected: false
                });
            }
            trace("Game State (Ship, Level) is ready.", false);
        }

        function initNeuralNetwork() {
            trace("Constructing Neural Network and Data Collector...", false);
            neuralNet = new NeuralNetwork(
                NN_CONSTANTS.INPUT_SIZE, 
                NN_CONSTANTS.HIDDEN_SIZE, 
                NN_CONSTANTS.OUTPUT_SIZE, 
                NN_CONSTANTS.LEARNING_RATE
            );
            dataCollector = new DataCollector();
            trace(`SUCCESS: Neural Network initialized: I:${NN_CONSTANTS.INPUT_SIZE} H:${NN_CONSTANTS.HIDDEN_SIZE} O:${NN_CONSTANTS.OUTPUT_SIZE}`, false);
        }
        
        function runSanityChecks() {
            try {
                trace("--- Running Game Engine Sanity Checks ---", false);
                // Check critical constants and data types using the checkType utility
                checkType(CONSTANTS.GRAVITY, 'number', 'CONSTANTS.GRAVITY', 'SanityCheck');
                checkType(gameState.ship.x, 'number', 'gameState.ship.x', 'SanityCheck');
                checkType(gameState.ship.velocity.y, 'number', 'gameState.ship.velocity.y', 'SanityCheck');

                // Check level data integrity
                if (gameState.obstacles.length !== 5 || gameState.diamonds.length !== 10) {
                    throw new Error(`Level data integrity check failed (Obstacles: ${gameState.obstacles.length}, Diamonds: ${gameState.diamonds.length}).`);
                }
                
                trace("--- Sanity Checks Passed ---", false);
                return true;

            } catch (e) {
                trace(`FATAL ERROR during Sanity Checks: ${e.message}`, true);
                return false;
            }
        }

        // --- AI LOGIC AND TRAINING ---

        function runAISanityTraining() {
            trace("--- STARTING AI SANITY UNIT TEST (SIMULATION PHASE) ---", false);
            const NUM_TEST_PLAYTHROUGHS = 10;
            const TARGET_ERROR = 0.05;
            let totalError = Infinity;

            const oldMode = gameState.currentAIMode;
            gameState.currentAIMode = AI_MODE.COLLECT;
            
            trace(`Starting data gathering for ${NUM_TEST_PLAYTHROUGHS} simulated playthroughs...`, false);
            
            // 1. Gather Data (Simulated Playthroughs)
            for (let p = 0; p < NUM_TEST_PLAYTHROUGHS; p++) {
                initGameState(false); 
                gameState.playthroughs = p; 
                let step = 0;
                while(gameState.ship.isAlive && !gameState.ship.hasLanded && step < 2000) { // Safety break
                    const ship = gameState.ship;
                    
                    // AI Decision
                    const { nearestDiamond, nearestObs } = getNearestFeatures();
                    const input = normalizeInput(ship, nearestDiamond, nearestObs);
                    const target = getOptimalAction();
                    dataCollector.record(input, target);
                    
                    // Apply Target Action (Rotation/Thrust Flag Set)
                    applyNNOutput(target); 
                    
                    // Physics Step (Apply velocity changes, NO particles)
                    applyThrust(ship, false); 
                    updatePhysics(); 
                    checkCollision();
                    step++;
                }
                trace(`Simulated playthrough ${p + 1} complete. Steps: ${step}. Data points: ${dataCollector.data.length}`, false);
            }
            trace(`Data collection finished. Total training instances: ${dataCollector.data.length}.`, false);
            
            // 2. Train the Network and Check Convergence
            trace(`Starting backpropagation training (Max 2000 epochs, Target Error: ${TARGET_ERROR})...`, false);
            let epoch = 0;
            let trainingData = dataCollector.data;
            dataCollector.clear();

            while(totalError > TARGET_ERROR && epoch < 2000) {
                let currentEpochError = 0;
                for (let i = 0; i < trainingData.length; i++) {
                    const data = trainingData[i];
                    currentEpochError += neuralNet.train(data.input, data.target_output);
                }
                totalError = currentEpochError / trainingData.length;
                totalError = checkFloatAndStop(totalError, 'totalError', 'runAISanityTraining');
                if (epoch % 200 === 0) trace(`[TRAINING] Epoch ${epoch}: Avg Error: ${totalError.toFixed(6)}`, false);
                epoch++;
            }

            if (totalError <= TARGET_ERROR) {
                trace(`SUCCESS: NN Sanity Test PASSED. Converged in ${epoch} epochs (Final Error: ${totalError.toFixed(6)})`, false);
            } else {
                trace(`WARNING: NN Sanity Test FAILED. Did not converge fully (Final Error: ${totalError.toFixed(6)})`, false);
            }
            
            // Restore initial game state
            initGameState(true);
            gameState.currentAIMode = oldMode;
            trace("--- AI SANITY UNIT TEST FINISHED. Ready for main loop. ---", false);
        }
        
        function getNearestFeatures() {
            const ship = gameState.ship;
            let nearestDiamond = null;
            let nearestObs = null;
            let minDiamondDistSq = Infinity;
            let minObsDistSq = Infinity;
            gameState.diamonds.forEach(d => {
                if (!d.collected) {
                    const distSq = (ship.x - d.x)**2 + (ship.y - d.y)**2;
                    if (distSq < minDiamondDistSq) { minDiamondDistSq = distSq; nearestDiamond = d; }
                }
            });
            gameState.obstacles.forEach(obs => {
                const obsCenterX = obs.x + obs.w / 2;
                const obsCenterY = obs.y + obs.h / 2;
                const distSq = (ship.x - obsCenterX)**2 + (ship.y - obsCenterY)**2;
                if (distSq < minObsDistSq) { minObsDistSq = distSq; nearestObs = obs; }
            }
            );
            return { nearestDiamond, nearestObs };
        }

        function normalizeInput(ship, nearestDiamond, nearestObs) {
            const w = canvas.width;
            const h = canvas.height;
            const maxV = 10;
            return [
                checkFloatAndStop(ship.x / w, 'ship.x / w', 'normalizeInput'),
                checkFloatAndStop(ship.y / h, 'ship.y / h', 'normalizeInput'), 
                checkFloatAndStop(ship.velocity.x / maxV, 'ship.velocity.x / maxV', 'normalizeInput'), 
                checkFloatAndStop(ship.velocity.y / maxV, 'ship.velocity.y / maxV', 'normalizeInput'),
                checkFloatAndStop(ship.angle / (2 * Math.PI), 'ship.angle / 2PI', 'normalizeInput'),
                checkFloatAndStop(nearestDiamond ? nearestDiamond.x / w : 0.5, 'Diamond X Norm', 'normalizeInput'), 
                checkFloatAndStop(nearestDiamond ? nearestDiamond.y / h : 0.5, 'Diamond Y Norm', 'normalizeInput'),
                checkFloatAndStop(nearestObs ? nearestObs.x / w : 0.5, 'Obs X Norm', 'normalizeInput'), 
                checkFloatAndStop(nearestObs ? nearestObs.y / h : 0.5, 'Obs Y Norm', 'normalizeInput'),
                checkFloatAndStop(nearestObs ? (nearestObs.w + nearestObs.h) / (w + h) : 0, 'Obs Size Norm', 'normalizeInput')
            ];
        }

        function getOptimalAction() {
            const ship = gameState.ship;
            const targetOutput = [0, 0, 0];
            let nearestDiamond = null;
            let minDistanceSq = Infinity;
            gameState.diamonds.forEach(d => {
                if (!d.collected) {
                    const dx = checkFloatAndStop(ship.x - d.x, 'dx', 'getOptimalAction');
                    const dy = checkFloatAndStop(d.y - ship.y, 'dy', 'getOptimalAction');
                    const distSq = checkFloatAndStop(dx * dx + dy * dy, 'distSq', 'getOptimalAction');
                    if (distSq < minDistanceSq) { minDistanceSq = distSq; nearestDiamond = d; }
                }
            });

            if (nearestDiamond) {
                const dx = checkFloatAndStop(nearestDiamond.x - ship.x, 'dx', 'getOptimalAction');
                const dy = checkFloatAndStop(nearestDiamond.y - ship.y, 'dy', 'getOptimalAction');
                const targetHeading = checkFloatAndStop(Math.atan2(dy, dx), 'targetHeading', 'getOptimalAction');
                
                let angleDiff = checkFloatAndStop(targetHeading - ship.angle, 'angleDiff', 'getOptimalAction');
                if (angleDiff > Math.PI) angleDiff = checkFloatAndStop(angleDiff - 2 * Math.PI, 'angleDiff - 2PI', 'getOptimalAction');
                if (angleDiff < -Math.PI) angleDiff = checkFloatAndStop(angleDiff + 2 * Math.PI, 'angleDiff + 2PI', 'getOptimalAction');

                if (checkFloatAndStop(angleDiff, 'angleDiff', 'getOptimalAction') > 0.1) targetOutput[2] = 1; 
                else if (angleDiff < -0.1) targetOutput[1] = 1; 

                if (Math.abs(angleDiff) < Math.PI / 3) { targetOutput[0] = 1; } 
            }
            return targetOutput;
        }

        function applyNNOutput(output) {
            const ship = gameState.ship;
            ship.isThrusting = output[0] > 0.5;
            const rotateLeft = output[1] > 0.5;
            const rotateRight = output[2] > 0.5;
            
            if (rotateLeft && !rotateRight) { ship.angle = checkFloatAndStop(ship.angle - CONSTANTS.ROTATION_SPEED, 'ship.angle', 'applyNNOutput'); } 
            else if (rotateRight && !rotateLeft) { ship.angle = checkFloatAndStop(ship.angle + CONSTANTS.ROTATION_SPEED, 'ship.angle', 'applyNNOutput'); } 
            
            if (ship.angle > 2 * Math.PI) ship.angle = checkFloatAndStop(ship.angle - 2 * Math.PI, 'ship.angle normalized', 'applyNNOutput');
            if (ship.angle < 0) ship.angle = checkFloatAndStop(ship.angle + 2 * Math.PI, 'ship.angle normalized', 'applyNNOutput');
            
            return ship.isThrusting;
        }


        // --- PHYSICS AND GAME UPDATES ---
        
        function createThrustParticle() {
            const ship = gameState.ship;
            const particles = gameState.particles;
            if (!ship.isAlive || ship.hasLanded) return;
            
            const exhaustAngle = ship.angle + Math.PI; 
            const sizeOffset = ship.size * 1.5;
            const particleSpeed = 1.5;

            particles.push({
                x: checkFloatAndStop(ship.x + Math.cos(exhaustAngle) * sizeOffset, 'Particle X', 'createThrustParticle'),
                y: checkFloatAndStop(ship.y + Math.sin(exhaustAngle) * sizeOffset, 'Particle Y', 'createThrustParticle'),
                vx: checkFloatAndStop(ship.velocity.x + Math.cos(exhaustAngle) * particleSpeed * (Math.random() * 0.5 + 0.5), 'Particle VX', 'createThrustParticle'),
                vy: checkFloatAndStop(ship.velocity.y + Math.sin(exhaustAngle) * particleSpeed * (Math.random() * 0.5 + 0.5), 'Particle VY', 'createThrustParticle'),
                alpha: 1.0,
                size: Math.random() * 3 + 1,
                lifetime: 100
            });
        }

        function applyThrust(ship, isVisibleGame) {
            if (!ship.isThrusting) return;
            
            ship.velocity.x = checkFloatAndStop(ship.velocity.x + Math.cos(ship.angle) * CONSTANTS.THRUST_POWER, 'ship.velocity.x', 'applyThrust');
            ship.velocity.y = checkFloatAndStop(ship.velocity.y + Math.sin(ship.angle) * CONSTANTS.THRUST_POWER, 'ship.velocity.y', 'applyThrust');

            // Create particles ONLY for the visible game loop
            if (isVisibleGame && Math.random() < 0.8) {
                 createThrustParticle();
            }
        }

        function updatePhysics() {
            try {
                const ship = gameState.ship;

                ship.velocity.y = checkFloatAndStop(ship.velocity.y + CONSTANTS.GRAVITY, 'ship.velocity.y', 'updatePhysics');

                ship.x = checkFloatAndStop(ship.x + ship.velocity.x, 'ship.x', 'updatePhysics');
                ship.y = checkFloatAndStop(ship.y + ship.velocity.y, 'ship.y', 'updatePhysics');

                if (ship.x < 0) ship.x = canvas.width;
                if (ship.x > canvas.width) ship.x = 0;

            } catch (e) {
                trace(`Exception in updatePhysics: ${e.message}`, true);
            }
        }
        
        function updateParticles() {
            try {
                const particles = gameState.particles;
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x = checkFloatAndStop(p.x + p.vx, 'Particle X', 'updateParticles');
                    p.y = checkFloatAndStop(p.y + p.vy, 'Particle Y', 'updateParticles');
                    p.alpha = checkFloatAndStop(p.alpha - 0.015, 'Particle Alpha', 'updateParticles');
                    if (p.alpha <= 0 || p.lifetime-- <= 0) {
                        particles.splice(i, 1);
                    }
                }
            } catch (e) {
                trace(`Exception in updateParticles: ${e.message}`, true);
            }
        }
        
        function checkCollision() {
            try {
                const ship = gameState.ship;
                const shipRadius = ship.size; 
                let collisionDetected = false;

                // Obstacle collision
                for (const obs of gameState.obstacles) {
                    const closestX = Math.max(obs.x, Math.min(ship.x, obs.x + obs.w));
                    const closestY = Math.max(obs.y, Math.min(ship.y, obs.y + obs.h));
                    const dx = checkFloatAndStop(ship.x - closestX, 'Collision DX', 'checkCollision');
                    const dy = checkFloatAndStop(ship.y - closestY, 'Collision DY', 'checkCollision');

                    if (checkFloatAndStop(dx * dx + dy * dy, 'Collision Dist Sq', 'checkCollision') < (shipRadius * shipRadius)) {
                        ship.isAlive = false;
                        explosionTimer = 30;
                        trace("Obstacle collision detected!", true);
                        collisionDetected = true;
                        break;
                    }
                }
                if (collisionDetected) return true;

                // Diamond collection
                for (let i = gameState.diamonds.length - 1; i >= 0; i--) {
                    const d = gameState.diamonds[i];
                    if (d.collected) continue;
                    const distance = checkFloatAndStop(Math.sqrt((ship.x - d.x)**2 + (ship.y - d.y)**2), 'Diamond Distance', 'checkCollision');
                    if (distance < shipRadius + d.size) {
                        d.collected = true;
                        gameState.score += CONSTANTS.SCORE_DIAMOND;
                        trace(`Diamond collected! Current Score: ${gameState.score}`, false);
                    }
                }
                return false;
            } catch (e) {
                trace(`Exception in checkCollision: ${e.message}`, true);
                return false;
            }
        }

        function runAI() {
            try {
                const ship = gameState.ship;
                const memory = ship.memory;

                if (!ship.isAlive || ship.hasLanded) {
                    ship.isThrusting = false;
                    memory.aiStatus = "IDLE (Game Over)";
                    return;
                }

                const { nearestDiamond, nearestObs } = getNearestFeatures();
                const input = normalizeInput(ship, nearestDiamond, nearestObs);
                let output = [0, 0, 0];

                if (gameState.currentAIMode === AI_MODE.COLLECT) {
                    // Data generation using hardcoded targets
                    output = getOptimalAction();
                    applyNNOutput(output); // Sets ship.isThrusting/angle
                    
                    // Record data
                    if (ship.isAlive && !ship.hasLanded) {
                        dataCollector.record(input, output);
                    }
                    
                    ship.memory.aiStatus = `Data Collection Run ${gameState.playthroughs + 1}/${NN_CONSTANTS.MAX_PLAYTHROUGHS}`;

                    if (!ship.isAlive || ship.hasLanded) {
                        gameState.playthroughs++;
                        
                        if (gameState.playthroughs >= NN_CONSTANTS.MAX_PLAYTHROUGHS) {
                            
                            // FIX: Set mode immediately, but DEFER heavy training to prevent freezing
                            gameState.currentAIMode = AI_MODE.NN_CONTROL;
                            trace("Data Collection finished. Starting deferred final training.", false);
                            
                            setTimeout(() => { // Defer the blocking operation
                                // Final Training before NN control takes over
                                trace("Executing deferred Final training...", false);
                                const EPOCHS = 5000;
                                let finalError = 0;
                                const trainingData = dataCollector.data;

                                for (let e = 0; e < EPOCHS; e++) {
                                    let currentEpochError = 0;
                                    for (let i = 0; i < trainingData.length; i++) {
                                        currentEpochError += neuralNet.train(trainingData[i].input, trainingData[i].target_output);
                                    }
                                    finalError = currentEpochError / trainingData.length;
                                    finalError = checkFloatAndStop(finalError, 'finalError', 'runAI.FinalTraining');

                                    if (e % 1000 === 0) trace(`[FINAL TRAIN] Epoch ${e}: Avg Error: ${finalError.toFixed(6)}`, false);
                                }
                                
                                trace(`Final training complete. Final Error: ${finalError.toFixed(6)}`, false);

                                dataCollector.clear();
                                initGameState(false); // Reset happens AFTER deferred training
                                
                            }, 10); // Small delay
                            
                        } else {
                            initGameState(false); 
                        }
                    }

                } else if (gameState.currentAIMode === AI_MODE.NN_CONTROL) {
                    // NN execution phase
                    output = neuralNet.feedforward(input);
                    applyNNOutput(output); // Sets ship.isThrusting/angle
                    
                    ship.memory.aiStatus = `NN Control. Thrust: ${output[0].toFixed(2)} R-L: ${output[1].toFixed(2)} R-R: ${output[2].toFixed(2)}`;
                }
                
            } catch (e) {
                trace(`Exception in runAI: ${e.message}`, true);
            }
        }


        function updateGame() {
            try {
                const ship = gameState.ship;
                
                if (!ship.isAlive || ship.hasLanded) {
                    if (explosionTimer > 0) explosionTimer--;
                    return; 
                }

                runAI();
                
                applyThrust(ship, true); // Apply thrust velocity and create particles
                
                updatePhysics();
                updateParticles();

                if (checkCollision()) return; 

                // Ground Check
                const collisionY = canvas.height - CONSTANTS.GROUND_HEIGHT;
                if (ship.y + ship.size > collisionY) {
                    ship.y = collisionY - ship.size;

                    if (Math.abs(ship.velocity.y) > CONSTANTS.CRITICAL_VELOCITY) {
                        ship.isAlive = false;
                        trace(`CRASH: Ground impact speed ${ship.velocity.y.toFixed(2)} > ${CONSTANTS.CRITICAL_VELOCITY}`, true);
                        explosionTimer = 30;
                    } else {
                        ship.hasLanded = true;
                        gameState.score += CONSTANTS.SCORE_LANDING;
                        trace(`SUCCESSFUL LANDING! Final Score: ${gameState.score}`, false);
                        explosionTimer = 60;
                    }
                    
                    ship.velocity.x = 0;
                    ship.velocity.y = 0;
                    ship.isThrusting = false;
                    sendNotification(ship.hasLanded ? 'SUCCESSFUL LANDING!' : 'CRASHED!', `Final Score: ${gameState.score}`);
                }

            } catch (e) {
                trace(`Exception in updateGame: ${e.message}`, true);
            }
        }
        
        // --- DRAWING ---

        function drawParticles() {
            ctx.fillStyle = 'red';
            gameState.particles.forEach(p => {
                ctx.globalAlpha = p.alpha;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;
        }
        
        function drawGround() {
            ctx.fillStyle = 'darkgreen';
            ctx.fillRect(0, canvas.height - CONSTANTS.GROUND_HEIGHT, canvas.width, CONSTANTS.GROUND_HEIGHT);
            ctx.strokeStyle = 'lime';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - CONSTANTS.GROUND_HEIGHT);
            ctx.lineTo(canvas.width, canvas.height - CONSTANTS.GROUND_HEIGHT);
            ctx.stroke();
        }

        function drawObstacles() {
            ctx.fillStyle = 'gray';
            ctx.strokeStyle = '#444';
            gameState.obstacles.forEach(obs => {
                ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
            });
        }

        function drawDiamonds() {
            gameState.diamonds.forEach(d => {
                if (!d.collected) {
                    ctx.fillStyle = 'cyan';
                    ctx.save();
                    ctx.translate(d.x, d.y);
                    ctx.rotate(Math.PI / 4);
                    ctx.fillRect(-d.size, -d.size, d.size * 2, d.size * 2);
                    ctx.restore();
                }
            });
        }

        function drawSpaceship() {
            const ship = gameState.ship;
            ctx.save();
            ctx.translate(ship.x, ship.y);
            ctx.rotate(ship.angle - Math.PI / 2); 

            ctx.beginPath();
            ctx.moveTo(0, -ship.size);
            ctx.lineTo(-ship.size, ship.size);
            ctx.lineTo(ship.size, ship.size);
            ctx.closePath();

            ctx.fillStyle = ship.isAlive ? 'silver' : 'darkred';
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.stroke();

            if (ship.isThrusting && ship.isAlive) {
                ctx.beginPath();
                ctx.moveTo(-ship.size / 2, ship.size);
                ctx.lineTo(0, ship.size + 10 + Math.random() * 5);
                ctx.lineTo(ship.size / 2, ship.size);
                ctx.fillStyle = 'orange';
                ctx.fill();
            }

            ctx.restore();
        }
        
        function updateUI() {
            const ship = gameState.ship;
            const status = ship.memory.aiStatus || 'Awaiting command...';
            
            aiModeSpan.textContent = gameState.currentAIMode;
            aiStatusSpan.textContent = status;

            vyDisplaySpan.textContent = ship.velocity.y.toFixed(2);
            vyDisplaySpan.className = ship.velocity.y > CONSTANTS.MAX_SAFE_VELOCITY ? 'danger' : 'safe';
            scoreDisplaySpan.textContent = gameState.score;
        }

        function gameLoop() {
            try {
                if (!ctx) {
                    trace("FATAL: Canvas 2D context is missing. Cannot draw graphics.", true);
                    return; 
                }
                
                // Drawing Phase
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGround();
                drawObstacles();
                drawDiamonds();
                drawParticles();
                drawSpaceship();

                // Logic/Update Phase
                updateGame();
                updateUI(); 

                // Handle Game Over Screen Display
                if (!gameState.ship.isAlive || gameState.ship.hasLanded) {
                    if (explosionTimer === 0) {
                        let finalScore = gameState.ship.hasLanded ? gameState.score + CONSTANTS.SCORE_LANDING : gameState.score;
                        let message = gameState.ship.hasLanded ? 'SUCCESSFUL LANDING!' : 'CRASHED!';
                        let color = gameState.ship.hasLanded ? 'lime' : 'red';
                        
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        ctx.fillStyle = color;
                        ctx.font = '48px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(message, canvas.width / 2, canvas.height / 2);

                        ctx.font = '30px sans-serif';
                        ctx.fillText(`Final Score: ${finalScore}`, canvas.width / 2, canvas.height / 2 + 50);
                    }
                }
                
                animationFrameId = requestAnimationFrame(gameLoop);

            } catch (e) {
                trace(`Critical exception in gameLoop: ${e.message}`, true);
            }
        }

        // --- MASTER STARTUP PROCEDURE ---
        
        function startSimulationAndTraining() {
            trace("--- Starting full simulation and training procedure ---", false);
            try {
                // 1. Initial setup (quick operations)
                initConstants();
                initNeuralNetwork(); 
                initGameState(true);
                
                // 2. Run Sanity Checks (quick check only)
                if (!runSanityChecks()) {
                    trace("FATAL: Game failed initial checks. Startup halted.", true);
                    return;
                }
                
                // 3. Start Main Loop BEFORE heavy training to show UI immediately
                requestNotificationPermission();
                updateUI(); 
                trace("Initialization complete. Starting game loop. AI Sanity Test running in background.", false);
                gameLoop();
                
                // FIX: DEFER HEAVY TRAINING to prevent blocking the UI
                setTimeout(() => {
                    try {
                        trace("Executing deferred AI Sanity Unit Test...", false);
                        runAISanityTraining(); // Heavy computational task
                    } catch (e) {
                        trace(`Error during deferred AI Sanity Training: ${e.message}`, true);
                    }
                }, 10); // 10ms delay allows the browser to draw the initial screen first.

            } catch (e) {
                trace(`CRITICAL FAILURE in simulation startup procedure: ${e.message}`, true);
            }
        }
        
        let startupAttempts = 0;
        const MAX_ATTEMPTS = 5;

        // This function handles waiting for the DOM
        function checkAndStartGame() {
            try {
                // Try to acquire necessary DOM references
                initDOMReferences(); 
                
                // If successful, proceed to the heavy simulation/training
                startSimulationAndTraining();

            } catch (e) {
                startupAttempts++;
                trace(`DOM readiness check failed (Attempt ${startupAttempts}/${MAX_ATTEMPTS}). Retrying in 500ms...`, false);
                if (startupAttempts < MAX_ATTEMPTS) {
                    setTimeout(checkAndStartGame, 500);
                } else {
                    trace("FATAL: Failed to initialize DOM after maximum attempts. Check element IDs.", true);
                }
            }
        }

        window.onload = checkAndStartGame;

    </script>
</body>
</html>
