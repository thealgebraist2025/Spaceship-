<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Autonomous Collector Lander</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 2px solid #fff;
            background-color: #05051a;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-family: sans-serif;
            font-size: 14px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            min-width: 150px;
        }
        .safe { color: lime; }
        .danger { color: red; }
        .score-display { font-weight: bold; color: yellow; }

        /* Trace Log Area */
        #log-area {
            width: 800px;
            height: 100px;
            margin-top: 10px;
            background-color: #111;
            color: #eee;
            font-family: monospace;
            padding: 5px;
            border: 1px solid #444;
            overflow-y: scroll;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="log-area">Trace Log:</div>
    </div>
    
    <div id="info">
        AI Mode: <span id="ai-mode">Collect</span><br>
        AI Status: <span id="ai-status">Initializing...</span><br>
        Vertical Speed: <span id="vy-display">0.00</span><br>
        Score: <span id="score-display" class="score-display">0</span>
    </div>

    <script>
        // --- Immediate Global Setup ---
        const logArea = document.getElementById('log-area');

        // Global DOM References 
        let canvas, ctx, aiStatusSpan, aiModeSpan, vyDisplaySpan, scoreDisplaySpan;

        let animationFrameId = null; 
        let explosionTimer = 0; 
        let notificationPermission = 'default';

        // --- Logging and Type Checking Utility (Unchanged) ---
        
        function trace(message, isError = false) {
            // ... (trace implementation)
            if (typeof message !== 'string') message = String(message);
            if (typeof isError !== 'boolean') isError = false; 

            const time = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.textContent = `${time} [${isError ? 'ERROR' : 'INFO'}] ${message}`;
            logEntry.style.color = isError ? 'red' : 'inherit';
            
            if (logArea) {
                logArea.prepend(logEntry);
                while (logArea.children.length > 50) {
                    logArea.removeChild(logArea.lastChild);
                }
            } else {
                 if (isError) console.error(`[${time} ERROR] ${message}`);
                 else console.log(`[${time} INFO] ${message}`);
            }

            if (isError) {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                    trace("Game loop stopped due to critical error.", true);
                }
            }
        }

        function checkType(variable, expectedType, variableName, context = 'game') {
            if (variable === null || variable === undefined || typeof variable !== expectedType) {
                const value = variable === null ? 'null' : variable === undefined ? 'undefined' : variable;
                const type = typeof variable;
                const errorMessage = `[${context}] CRITICAL TYPE ERROR: ${variableName} expected ${expectedType} but got ${type} (Value: ${value})`;
                trace(errorMessage, true);
                throw new Error(`Type error in ${variableName}`);
            }
        }
        
        // --- Notification Functions (Unchanged) ---
        function requestNotificationPermission() { /* ... */ }
        function sendNotification(title, body) { /* ... */ }


        // --- Game Constants and State Containers ---
        const CONSTANTS = {};
        const AI_MODE = { COLLECT: 'COLLECT', LANDING: 'LANDING', NN_CONTROL: 'NN_CONTROL' };
        
        const NN_CONSTANTS = {
            INPUT_SIZE: 10,   // Ship X/Y, Velocity X/Y, Angle, Nearest Diamond X/Y, Nearest Obs X/Y, Obs W/H
            HIDDEN_SIZE: 16,
            OUTPUT_SIZE: 3,   // [Thrust, Rotate_Left, Rotate_Right] (Binary decisions)
            LEARNING_RATE: 0.1,
            MAX_PLAYTHROUGHS: 50
        };

        let gameState = {
            score: 0,
            playthroughs: 0,
            currentAIMode: AI_MODE.COLLECT,
            ship: {},
            obstacles: [],
            diamonds: [],
            particles: []
        };
        
        let neuralNet;
        let dataCollector;

        // --- Neural Network Implementation ---

        class NeuralNetwork {
            constructor(inputSize, hiddenSize, outputSize, learningRate) {
                this.lr = learningRate;

                // Weights (Initialized randomly)
                this.weights_ih = this.randomMatrix(inputSize, hiddenSize); // Input -> Hidden
                this.weights_ho = this.randomMatrix(hiddenSize, outputSize); // Hidden -> Output

                // Biases (Initialized randomly)
                this.bias_h = this.randomVector(hiddenSize);
                this.bias_o = this.randomVector(outputSize);
            }

            randomMatrix(rows, cols) {
                const matrix = Array(rows).fill(0).map(() => 
                    Array(cols).fill(0).map(() => (Math.random() * 2 - 1) * 0.1)
                );
                return matrix;
            }

            randomVector(size) {
                return Array(size).fill(0).map(() => (Math.random() * 2 - 1) * 0.1);
            }

            sigmoid(x) {
                return 1 / (1 + Math.exp(-x));
            }

            sigmoidDerivative(y) {
                // y = sigmoid(x)
                return y * (1 - y);
            }

            dot(matrixA, matrixB) {
                if (matrixA[0].length !== matrixB.length) throw new Error("Dot product dimensions mismatch");
                const resultRows = matrixA.length;
                const resultCols = matrixB[0].length;
                const result = Array(resultRows).fill(0).map(() => Array(resultCols).fill(0));

                for (let i = 0; i < resultRows; i++) {
                    for (let j = 0; j < resultCols; j++) {
                        let sum = 0;
                        for (let k = 0; k < matrixA[0].length; k++) {
                            sum += matrixA[i][k] * matrixB[k][j];
                        }
                        result[i][j] = sum;
                    }
                }
                return result;
            }

            dotVector(matrix, vector) {
                const vectorMatrix = vector.map(v => [v]);
                const resultMatrix = this.dot(matrix, vectorMatrix);
                return resultMatrix.map(row => row[0]);
            }
            
            // Convert an array (1D vector) into a 1xN matrix
            vectorToRowMatrix(vector) {
                return [vector];
            }
            // Convert an array (1D vector) into an Nx1 matrix
            vectorToColMatrix(vector) {
                return vector.map(v => [v]);
            }
            // Transpose a matrix
            transpose(matrix) {
                const rows = matrix.length;
                const cols = matrix[0].length;
                const result = Array(cols).fill(0).map(() => Array(rows).fill(0));
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        result[j][i] = matrix[i][j];
                    }
                }
                return result;
            }
            
            // Add two matrices/vectors element-wise
            add(matrixA, matrixB) {
                const rows = matrixA.length;
                const cols = matrixA[0].length;
                const result = Array(rows).fill(0).map(() => Array(cols).fill(0));
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        result[i][j] = matrixA[i][j] + matrixB[i][j];
                    }
                }
                return result;
            }
            
            // Subtract two matrices/vectors element-wise
            subtract(matrixA, matrixB) {
                 const rows = matrixA.length;
                 const cols = matrixA[0].length;
                 const result = Array(rows).fill(0).map(() => Array(cols).fill(0));
                 for (let i = 0; i < rows; i++) {
                     for (let j = 0; j < cols; j++) {
                         result[i][j] = matrixA[i][j] - matrixB[i][j];
                     }
                 }
                 return result;
            }

            // Multiply a matrix by a scalar or element-wise (Hadamard product)
            multiply(matrixA, matrixB) {
                if (typeof matrixB === 'number') { // Scalar multiplication
                    const rows = matrixA.length;
                    const cols = matrixA[0].length;
                    const result = Array(rows).fill(0).map(() => Array(cols).fill(0));
                    for (let i = 0; i < rows; i++) {
                        for (let j = 0; j < cols; j++) {
                            result[i][j] = matrixA[i][j] * matrixB;
                        }
                    }
                    return result;
                } else { // Hadamard product (element-wise multiplication)
                    const rows = matrixA.length;
                    const cols = matrixA[0].length;
                    const result = Array(rows).fill(0).map(() => Array(cols).fill(0));
                    for (let i = 0; i < rows; i++) {
                        for (let j = 0; j < cols; j++) {
                            result[i][j] = matrixA[i][j] * matrixB[i][j];
                        }
                    }
                    return result;
                }
            }

            // Apply a function to every element of a matrix/vector
            map(matrix, func) {
                return matrix.map(row => 
                    row.map(val => func(val))
                );
            }

            feedforward(input_array) {
                // 1. Calculate Hidden Layer
                const inputs = this.vectorToColMatrix(input_array);
                let hidden = this.dot(this.weights_ih, inputs);
                
                // Add Bias H
                hidden = hidden.map((row, i) => [row[0] + this.bias_h[i]]);

                // Activation function (Sigmoid)
                const hidden_output = this.map(hidden, this.sigmoid);

                // 2. Calculate Output Layer
                let output = this.dot(this.weights_ho, hidden_output);

                // Add Bias O
                output = output.map((row, i) => [row[0] + this.bias_o[i]]);
                
                // Activation function (Sigmoid)
                const final_output = this.map(output, this.sigmoid);

                return final_output.map(row => row[0]); // Return as 1D array
            }

            train(input_array, target_array) {
                // Perform Feedforward to get the hidden and output states
                const inputs = this.vectorToColMatrix(input_array);
                
                // --- FF Pass ---
                let hidden = this.dot(this.weights_ih, inputs);
                hidden = hidden.map((row, i) => [row[0] + this.bias_h[i]]);
                const hidden_output = this.map(hidden, this.sigmoid);

                let output = this.dot(this.weights_ho, hidden_output);
                output = output.map((row, i) => [row[0] + this.bias_o[i]]);
                const final_output = this.map(output, this.sigmoid);

                const targets = this.vectorToColMatrix(target_array);

                // --- Backpropagation Pass ---
                
                // 1. Calculate Output Errors
                let output_errors = this.subtract(targets, final_output);
                
                // 2. Calculate Output Gradient
                let gradients = this.map(final_output, this.sigmoidDerivative);
                gradients = this.multiply(gradients, output_errors);
                gradients = this.multiply(gradients, this.lr); // Apply learning rate

                // 3. Calculate Delta Weights HO
                const hidden_output_T = this.transpose(hidden_output);
                let delta_weights_ho = this.dot(gradients, hidden_output_T);

                // 4. Adjust Weights HO and Bias O
                this.weights_ho = this.add(this.weights_ho, delta_weights_ho);
                this.bias_o = this.add(this.bias_o, gradients.map(row => row)); // Use map to keep structure

                // 5. Calculate Hidden Layer Errors
                const weights_ho_T = this.transpose(this.weights_ho);
                let hidden_errors = this.dot(weights_ho_T, output_errors);
                
                // 6. Calculate Hidden Gradient
                let hidden_gradients = this.map(hidden_output, this.sigmoidDerivative);
                hidden_gradients = this.multiply(hidden_gradients, hidden_errors);
                hidden_gradients = this.multiply(hidden_gradients, this.lr); // Apply learning rate

                // 7. Calculate Delta Weights IH
                const inputs_T = this.transpose(inputs);
                let delta_weights_ih = this.dot(hidden_gradients, inputs_T);

                // 8. Adjust Weights IH and Bias H
                this.weights_ih = this.add(this.weights_ih, delta_weights_ih);
                this.bias_h = this.add(this.bias_h, hidden_gradients.map(row => row)); // Use map to keep structure

                // Calculate total error (used for convergence check)
                let errorSum = output_errors.reduce((sum, row) => sum + row[0] * row[0], 0);
                return errorSum;
            }
        }
        
        // --- Data Collection ---
        class DataCollector {
            constructor() {
                this.data = [];
            }

            record(input, target_output) {
                if (input.length !== NN_CONSTANTS.INPUT_SIZE || target_output.length !== NN_CONSTANTS.OUTPUT_SIZE) {
                     trace("Data record size mismatch!", true);
                     return;
                }
                this.data.push({ input, target_output });
            }

            clear() {
                this.data = [];
            }
        }

        // --- NN Helper Functions ---

        function normalizeInput(ship, nearestDiamond, nearestObs) {
            // Normalization is CRUCIAL for NN performance.
            const w = canvas.width;
            const h = canvas.height;
            const maxV = 10; // Assuming max velocity is around 10
            
            // Input vector: 10 elements
            return [
                ship.x / w, 
                ship.y / h, 
                ship.velocity.x / maxV, 
                ship.velocity.y / maxV,
                ship.angle / (2 * Math.PI),
                nearestDiamond ? nearestDiamond.x / w : 0.5, 
                nearestDiamond ? nearestDiamond.y / h : 0.5,
                nearestObs ? nearestObs.x / w : 0.5,
                nearestObs ? nearestObs.y / h : 0.5,
                nearestObs ? (nearestObs.w + nearestObs.h) / (w + h) : 0
            ];
        }

        function getOptimalAction() {
            // This is the hardcoded AI logic output, used as the "target" for training.
            const ship = gameState.ship;
            const targetOutput = [0, 0, 0]; // [Thrust, Rotate_Left, Rotate_Right]

            const altitude = canvas.height - CONSTANTS.GROUND_HEIGHT - ship.y;
            
            // Find Nearest Diamond
            let nearestDiamond = null;
            let minDistanceSq = Infinity;
            gameState.diamonds.forEach(d => {
                if (!d.collected) {
                    const dx = ship.x - d.x;
                    const dy = ship.y - d.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < minDistanceSq) {
                        minDistanceSq = distSq;
                        nearestDiamond = d;
                    }
                }
            });

            if (nearestDiamond) {
                const dx = nearestDiamond.x - ship.x;
                const dy = nearestDiamond.y - ship.y;
                const targetHeading = Math.atan2(dy, dx); 
                
                let angleDiff = targetHeading - ship.angle;
                if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                if (angleDiff > 0.1) targetOutput[2] = 1; // Rotate Right
                else if (angleDiff < -0.1) targetOutput[1] = 1; // Rotate Left

                if (Math.abs(angleDiff) < Math.PI / 3) {
                    targetOutput[0] = 1; // Thrust
                }
            }
            
            // Landing/Braking Override
            if (ship.velocity.y > 0.8 && altitude < canvas.height / 2) {
                 targetOutput[0] = 1; // Vertical Brake
                 const angleDiff = ship.angle - Math.PI / 2;
                 if (angleDiff > 0.05) targetOutput[1] = 1; // Rotate Left
                 else if (angleDiff < -0.05) targetOutput[2] = 1; // Rotate Right
            }
            
            return targetOutput;
        }

        function applyNNOutput(output) {
            const ship = gameState.ship;
            // Output: [Thrust, Rotate_Left, Rotate_Right]
            
            // Thrust is the most important, check if it's over the threshold
            ship.isThrusting = output[0] > 0.5;

            // Rotation is mutually exclusive
            const rotateLeft = output[1] > 0.5;
            const rotateRight = output[2] > 0.5;
            
            if (rotateLeft && !rotateRight) {
                 ship.angle -= CONSTANTS.ROTATION_SPEED;
            } else if (rotateRight && !rotateLeft) {
                 ship.angle += CONSTANTS.ROTATION_SPEED;
            } else if (rotateLeft && rotateRight) {
                 // Do nothing, net is confused, or they are very close (safer to not rotate)
            }
            
            // Normalize angle to [0, 2PI]
            if (ship.angle > 2 * Math.PI) ship.angle -= 2 * Math.PI;
            if (ship.angle < 0) ship.angle += 2 * Math.PI;
            
            return ship.isThrusting;
        }


        // --- Initialization and Sanity Checks ---

        function initDOMReferences() { /* ... unchanged ... */ }
        function initConstants() { /* ... unchanged ... */ }
        function initGameState(startFresh = true) {
             if (startFresh) gameState.playthroughs = 0;
             // ... (original initGameState logic)
             gameState.ship = {
                x: canvas.width / 2,
                y: 50,
                velocity: { x: 0, y: 0 },
                angle: Math.PI / 2, // Ship starts pointing down
                size: 15,
                isThrusting: false,
                isAlive: true,
                hasLanded: false,
                notified: false,
                memory: { lastAction: 'Init', aiStatus: 'Cruising...' }
            };

            gameState.obstacles = [
                { x: 100, y: 300, w: 150, h: 20 }, { x: 550, y: 200, w: 100, h: 20 },
                { x: 300, y: 450, w: 200, h: 20 }, { x: 50, y: 150, w: 50, h: 50 },
                { x: 650, y: 400, w: 150, h: 20 }
            ];

            gameState.diamonds = [];
            for (let i = 0; i < 10; i++) {
                gameState.diamonds.push({
                    x: Math.random() * (canvas.width - 40) + 20,
                    y: Math.random() * (canvas.height - CONSTANTS.GROUND_HEIGHT - 50) + 20,
                    size: 5,
                    collected: false
                });
            }
            trace("Game State (Ship, Level) initialized.", false);
        }
        function runSanityChecks() { /* ... unchanged ... */ }

        // --- Training and Sanity Testing ---

        function initNeuralNetwork() {
            neuralNet = new NeuralNetwork(
                NN_CONSTANTS.INPUT_SIZE, 
                NN_CONSTANTS.HIDDEN_SIZE, 
                NN_CONSTANTS.OUTPUT_SIZE, 
                NN_CONSTANTS.LEARNING_RATE
            );
            dataCollector = new DataCollector();
            trace(`Neural Network initialized: I:${NN_CONSTANTS.INPUT_SIZE} H:${NN_CONSTANTS.HIDDEN_SIZE} O:${NN_CONSTANTS.OUTPUT_SIZE}`, false);
        }
        
        function getNearestFeatures() {
            const ship = gameState.ship;
            let nearestDiamond = null;
            let nearestObs = null;
            let minDiamondDistSq = Infinity;
            let minObsDistSq = Infinity;
            
            // Find nearest diamond
            gameState.diamonds.forEach(d => {
                if (!d.collected) {
                    const distSq = (ship.x - d.x)**2 + (ship.y - d.y)**2;
                    if (distSq < minDiamondDistSq) {
                        minDiamondDistSq = distSq;
                        nearestDiamond = d;
                    }
                }
            });
            
            // Find nearest obstacle
            gameState.obstacles.forEach(obs => {
                // Simplified distance check to obstacle center
                const obsCenterX = obs.x + obs.w / 2;
                const obsCenterY = obs.y + obs.h / 2;
                const distSq = (ship.x - obsCenterX)**2 + (ship.y - obsCenterY)**2;
                if (distSq < minObsDistSq) {
                    minObsDistSq = distSq;
                    nearestObs = obs;
                }
            });

            return { nearestDiamond, nearestObs };
        }

        function runAISanityTraining() {
            trace("--- Running NN Sanity Unit Test (10 Playthroughs) ---", false);
            const NUM_TEST_PLAYTHROUGHS = 10;
            const EPOCHS_PER_FRAME = 5;
            const TARGET_ERROR = 0.05;
            let totalError = Infinity;

            // 1. Gather Data (10 Playthroughs of the Hardcoded AI)
            const oldMode = gameState.currentAIMode;
            gameState.currentAIMode = AI_MODE.COLLECT;
            
            for (let p = 0; p < NUM_TEST_PLAYTHROUGHS; p++) {
                initGameState(false); // Do not reset playthrough counter
                gameState.playthroughs = p; // Ensure this is only used for data gathering
                while(gameState.ship.isAlive && !gameState.ship.hasLanded) {
                    const { nearestDiamond, nearestObs } = getNearestFeatures();
                    const input = normalizeInput(gameState.ship, nearestDiamond, nearestObs);
                    const target = getOptimalAction();
                    dataCollector.record(input, target);
                    
                    // Simulate a single game step using the AI logic
                    runHardcodedAI_CollectorOnly(); 
                    updatePhysics(); 
                    checkCollision();
                }
            }
            trace(`Collected ${dataCollector.data.length} training instances.`, false);
            
            // 2. Train the Network and Check Convergence
            let epoch = 0;
            let trainingData = dataCollector.data;
            dataCollector.clear();

            while(totalError > TARGET_ERROR && epoch < 2000) {
                let currentEpochError = 0;
                for (let i = 0; i < trainingData.length; i++) {
                    const data = trainingData[i];
                    currentEpochError += neuralNet.train(data.input, data.target_output);
                }
                totalError = currentEpochError / trainingData.length;
                if (epoch % 100 === 0) trace(`Epoch ${epoch}: Avg Error: ${totalError.toFixed(6)}`, false);
                epoch++;
            }

            if (totalError <= TARGET_ERROR) {
                trace(`NN Sanity Test PASSED. Converged in ${epoch} epochs (Error: ${totalError.toFixed(6)})`, false);
            } else {
                trace(`NN Sanity Test FAILED. Did not converge (Final Error: ${totalError.toFixed(6)})`, true);
            }
            
            // Restore initial game state
            initGameState(true);
            gameState.currentAIMode = oldMode;
        }

        // --- Game Logic Updates ---

        function runHardcodedAI_CollectorOnly() {
            // This logic is ONLY used for data collection and testing now.
            const ship = gameState.ship;
            const memory = ship.memory;

            if (!ship.isAlive || ship.hasLanded) return;
            
            const { nearestDiamond } = getNearestFeatures();
            const altitude = canvas.height - CONSTANTS.GROUND_HEIGHT - ship.y;
            ship.isThrusting = false;
            
            // Use the target output from getOptimalAction to apply the action
            const targetOutput = getOptimalAction();
            const isThrusting = applyNNOutput(targetOutput); // Apply the target action, essentially the old AI
            ship.isThrusting = isThrusting; // Set thrust flag
            
            memory.aiStatus = nearestDiamond ? "Collecting data for NN..." : "All collected (data mode)";

            // Update ship angle/velocity based on the applied target actions
            if (isThrusting) {
                ship.velocity.x += Math.cos(ship.angle) * CONSTANTS.THRUST_POWER;
                ship.velocity.y += Math.sin(ship.angle) * CONSTANTS.THRUST_POWER; 
            }
        }


        function runAI() {
            try {
                const ship = gameState.ship;
                const memory = ship.memory;

                if (!ship.isAlive || ship.hasLanded) {
                    ship.isThrusting = false;
                    memory.aiStatus = "IDLE (Game Over)";
                    return;
                }

                if (gameState.currentAIMode === AI_MODE.COLLECT) {
                    // This is the data generation phase (using hardcoded AI for targets)
                    runHardcodedAI_CollectorOnly();
                    
                    if (ship.isAlive && !ship.hasLanded) {
                        const { nearestDiamond, nearestObs } = getNearestFeatures();
                        const input = normalizeInput(ship, nearestDiamond, nearestObs);
                        const target = getOptimalAction();
                        dataCollector.record(input, target);
                    }
                    
                    if (!ship.isAlive || ship.hasLanded) {
                        gameState.playthroughs++;
                        trace(`Playthrough ${gameState.playthroughs} complete.`, false);
                        
                        if (gameState.playthroughs >= NN_CONSTANTS.MAX_PLAYTHROUGHS) {
                            gameState.currentAIMode = AI_MODE.NN_CONTROL;
                            trace("Data collection complete. Starting final NN training...", false);
                            
                            // *** FINAL TRAINING STEP ***
                            // You would typically train for thousands of epochs here
                            const EPOCHS = 5000;
                            let finalError = 0;
                            const trainingData = dataCollector.data;
                            for (let e = 0; e < EPOCHS; e++) {
                                let currentEpochError = 0;
                                for (let i = 0; i < trainingData.length; i++) {
                                    currentEpochError += neuralNet.train(trainingData[i].input, trainingData[i].target_output);
                                }
                                finalError = currentEpochError / trainingData.length;
                                if (e % 1000 === 0) trace(`Final Training Epoch ${e}: Avg Error: ${finalError.toFixed(6)}`, false);
                            }
                            trace(`Final training complete (Final Error: ${finalError.toFixed(6)})`, false);
                            dataCollector.clear();
                            initGameState(false); // Reset ship state for NN control
                            
                        } else {
                            // Reset ship and level for next playthrough
                            initGameState(false); 
                        }
                    }

                } else if (gameState.currentAIMode === AI_MODE.NN_CONTROL) {
                    // This is the NN execution phase
                    const { nearestDiamond, nearestObs } = getNearestFeatures();
                    const input = normalizeInput(ship, nearestDiamond, nearestObs);
                    const output = neuralNet.feedforward(input);
                    
                    const isThrusting = applyNNOutput(output);
                    
                    // Update Status
                    ship.memory.aiStatus = `NN Control. Thrust: ${output[0].toFixed(2)} R-L: ${output[1].toFixed(2)} R-R: ${output[2].toFixed(2)}`;

                    if (isThrusting) {
                        ship.velocity.x += Math.cos(ship.angle) * CONSTANTS.THRUST_POWER;
                        ship.velocity.y += Math.sin(ship.angle) * CONSTANTS.THRUST_POWER; 
                    }
                }
            } catch (e) {
                trace(`Exception in runAI: ${e.message}`, true);
            }
        }


        function updatePhysics() { /* ... unchanged ... */ }
        function updateGame() { /* ... unchanged ... */ }
        function updateUI() { /* ... unchanged ... */ }
        function drawSpaceship() { /* ... unchanged ... */ }
        function gameLoop() { /* ... unchanged ... */ }


        // --- Master Startup Procedure ---
        function startGameProcedure() {
            try {
                trace("--- Starting Master Initialization Procedure ---", false);
                
                if (!logArea) {
                     console.error("FATAL: Log area element could not be acquired. Tracing is disabled.");
                     return;
                }

                initDOMReferences();
                initConstants();
                initNeuralNetwork(); // Initialize the Neural Network
                initGameState(true);

                if (!runSanityChecks()) {
                    trace("FATAL: Game failed initial checks. Startup halted.", true);
                    return;
                }
                
                runAISanityTraining(); // *** Run NN Sanity Test ***
                
                requestNotificationPermission();

                updateUI(); 
                trace("Initialization complete. Starting game loop (Data Collection Mode).", false);
                gameLoop();

            } catch (e) {
                trace(`CRITICAL FAILURE in startup procedure: ${e.message}`, true);
            }
        }

        window.onload = startGameProcedure;

    </script>
</body>
</html>
